<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bembel: Bembel::ElementTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="bembeldoxy.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bembel_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bembel
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_bembel_1_1_element_tree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="class_bembel_1_1_element_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Bembel::ElementTree Class Reference<div class="ingroups"><a class="el" href="group___modules.html">Modules</a> &raquo; <a class="el" href="group___cluster_tree.html">ClusterTree</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class organizes an element structure on a <a class="el" href="class_bembel_1_1_geometry.html" title="this class wraps a GeometryVector and provides some basic functionality, like reading Geometry files">Geometry</a> object and handles refinement.  
 <a href="class_bembel_1_1_element_tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class organizes an element structure on a <a class="el" href="class_bembel_1_1_geometry.html" title="this class wraps a GeometryVector and provides some basic functionality, like reading Geometry files">Geometry</a> object and handles refinement. </p>
<p>This class implements a tree which realizes the refinement of the geometry. On the first level of refinement the leafs/elements are all patches of the geometry. Currently, the construction of the tree allows uniform refinement. In the refinement process each element get four sons and the neighborhood relations get updated.</p>
<p>The heart of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> is the leaf iterator which implements a Morton Z-curve. If an element get refined it gets replaced by it four sons element. This core routine can handle adaptive refinement but with some limitations in the resolution of neighborhood relations. </p>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00032">32</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a58f81b5d284dd488a9f3395ee1f6df51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a58f81b5d284dd488a9f3395ee1f6df51">ElementTree</a> (const <a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;)=delete</td></tr>
<tr class="memdesc:a58f81b5d284dd488a9f3395ee1f6df51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class.  <a href="class_bembel_1_1_element_tree.html#a58f81b5d284dd488a9f3395ee1f6df51">More...</a><br /></td></tr>
<tr class="separator:a58f81b5d284dd488a9f3395ee1f6df51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61c6b51388520dc85221a9bef523345"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#ac61c6b51388520dc85221a9bef523345">ElementTree</a> (<a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:ac61c6b51388520dc85221a9bef523345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class.  <a href="class_bembel_1_1_element_tree.html#ac61c6b51388520dc85221a9bef523345">More...</a><br /></td></tr>
<tr class="separator:ac61c6b51388520dc85221a9bef523345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2b31137879d87979e701ed6803938e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#afc2b31137879d87979e701ed6803938e">operator=</a> (const <a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;)=delete</td></tr>
<tr class="memdesc:afc2b31137879d87979e701ed6803938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class.  <a href="class_bembel_1_1_element_tree.html#afc2b31137879d87979e701ed6803938e">More...</a><br /></td></tr>
<tr class="separator:afc2b31137879d87979e701ed6803938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117f48957a95fe215903265c731aef6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a117f48957a95fe215903265c731aef6d">operator=</a> (<a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a117f48957a95fe215903265c731aef6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment operator for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class.  <a href="class_bembel_1_1_element_tree.html#a117f48957a95fe215903265c731aef6d">More...</a><br /></td></tr>
<tr class="separator:a117f48957a95fe215903265c731aef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b8984557610c903a2547b61c026406"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#ae3b8984557610c903a2547b61c026406">ElementTree</a> ()</td></tr>
<tr class="memdesc:ae3b8984557610c903a2547b61c026406"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructors  <a href="class_bembel_1_1_element_tree.html#ae3b8984557610c903a2547b61c026406">More...</a><br /></td></tr>
<tr class="separator:ae3b8984557610c903a2547b61c026406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4516d4246aa5a37ce3fa6a02e3431114"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a4516d4246aa5a37ce3fa6a02e3431114">ElementTree</a> (const <a class="el" href="class_bembel_1_1_geometry.html">Geometry</a> &amp;g, unsigned int max_level=0)</td></tr>
<tr class="memdesc:a4516d4246aa5a37ce3fa6a02e3431114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit constructor for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class.  <a href="class_bembel_1_1_element_tree.html#a4516d4246aa5a37ce3fa6a02e3431114">More...</a><br /></td></tr>
<tr class="separator:a4516d4246aa5a37ce3fa6a02e3431114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3769979afc7295c56ce721659d83b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#aa3769979afc7295c56ce721659d83b93">init_ElementTree</a> (const <a class="el" href="class_bembel_1_1_geometry.html">Geometry</a> &amp;g, unsigned int max_level)</td></tr>
<tr class="memdesc:aa3769979afc7295c56ce721659d83b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">init  <a href="class_bembel_1_1_element_tree.html#aa3769979afc7295c56ce721659d83b93">More...</a><br /></td></tr>
<tr class="separator:aa3769979afc7295c56ce721659d83b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae531dd7026ef12de425795fed380d7dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#ae531dd7026ef12de425795fed380d7dc">refineUniformly_recursion</a> (<a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;el)</td></tr>
<tr class="memdesc:ae531dd7026ef12de425795fed380d7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine the given element or it's sons.  <a href="class_bembel_1_1_element_tree.html#ae531dd7026ef12de425795fed380d7dc">More...</a><br /></td></tr>
<tr class="separator:ae531dd7026ef12de425795fed380d7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261632962d142694cb351536ce2de157"><td class="memItemLeft" align="right" valign="top"><a id="a261632962d142694cb351536ce2de157"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a261632962d142694cb351536ce2de157">refineUniformly</a> ()</td></tr>
<tr class="memdesc:a261632962d142694cb351536ce2de157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine all patches uniformly. <br /></td></tr>
<tr class="separator:a261632962d142694cb351536ce2de157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a36250d8b2392a96b31d1160ebcd25d"><td class="memItemLeft" align="right" valign="top"><a id="a8a36250d8b2392a96b31d1160ebcd25d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a8a36250d8b2392a96b31d1160ebcd25d">refinePatch</a> (int patch)</td></tr>
<tr class="memdesc:a8a36250d8b2392a96b31d1160ebcd25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a given patch. <br /></td></tr>
<tr class="separator:a8a36250d8b2392a96b31d1160ebcd25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebcceb563b798b9e06d4cc7f290af0e"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#abebcceb563b798b9e06d4cc7f290af0e">generatePointList</a> (Eigen::VectorXi *idct=nullptr) const</td></tr>
<tr class="memdesc:abebcceb563b798b9e06d4cc7f290af0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the coordinates of all points of the elements.  <a href="class_bembel_1_1_element_tree.html#abebcceb563b798b9e06d4cc7f290af0e">More...</a><br /></td></tr>
<tr class="separator:abebcceb563b798b9e06d4cc7f290af0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd44db6cc7ad2caf32cdafb7f7e54ef"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#adbd44db6cc7ad2caf32cdafb7f7e54ef">generateElementList</a> () const</td></tr>
<tr class="memdesc:adbd44db6cc7ad2caf32cdafb7f7e54ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of elements containing the indices of the vertices.  <a href="class_bembel_1_1_element_tree.html#adbd44db6cc7ad2caf32cdafb7f7e54ef">More...</a><br /></td></tr>
<tr class="separator:adbd44db6cc7ad2caf32cdafb7f7e54ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da89274800b8f17291dd801276f568d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a5da89274800b8f17291dd801276f568d">get_number_of_points</a> () const</td></tr>
<tr class="memdesc:a5da89274800b8f17291dd801276f568d"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter  <a href="class_bembel_1_1_element_tree.html#a5da89274800b8f17291dd801276f568d">More...</a><br /></td></tr>
<tr class="separator:a5da89274800b8f17291dd801276f568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd179822f5abd8261b3cceed00d91061"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#abd179822f5abd8261b3cceed00d91061">get_number_of_elements</a> () const</td></tr>
<tr class="memdesc:abd179822f5abd8261b3cceed00d91061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of elements in the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>.  <a href="class_bembel_1_1_element_tree.html#abd179822f5abd8261b3cceed00d91061">More...</a><br /></td></tr>
<tr class="separator:abd179822f5abd8261b3cceed00d91061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b2ff1bfaef5bce21b51f42b1a7e8ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#af2b2ff1bfaef5bce21b51f42b1a7e8ef">get_max_level</a> () const</td></tr>
<tr class="memdesc:af2b2ff1bfaef5bce21b51f42b1a7e8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum level of refinement.  <a href="class_bembel_1_1_element_tree.html#af2b2ff1bfaef5bce21b51f42b1a7e8ef">More...</a><br /></td></tr>
<tr class="separator:af2b2ff1bfaef5bce21b51f42b1a7e8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bb605f06602d6c962e2e6b04668f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#af3bb605f06602d6c962e2e6b04668f07">root</a> ()</td></tr>
<tr class="memdesc:af3bb605f06602d6c962e2e6b04668f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to the root <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>.  <a href="class_bembel_1_1_element_tree.html#af3bb605f06602d6c962e2e6b04668f07">More...</a><br /></td></tr>
<tr class="separator:af3bb605f06602d6c962e2e6b04668f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d696de6baf21b29b55411f04dd98ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a26d696de6baf21b29b55411f04dd98ce">root</a> () const</td></tr>
<tr class="memdesc:a26d696de6baf21b29b55411f04dd98ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const reference to the root <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>.  <a href="class_bembel_1_1_element_tree.html#a26d696de6baf21b29b55411f04dd98ce">More...</a><br /></td></tr>
<tr class="separator:a26d696de6baf21b29b55411f04dd98ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1837ca3dd10d0922264cd47618f5c66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___geometry.html#ga2a0fac9275fef7f9601b40a644585cec">PatchVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#af1837ca3dd10d0922264cd47618f5c66">get_geometry</a> () const</td></tr>
<tr class="memdesc:af1837ca3dd10d0922264cd47618f5c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const reference to the <a class="el" href="class_bembel_1_1_geometry.html" title="this class wraps a GeometryVector and provides some basic functionality, like reading Geometry files">Geometry</a>.  <a href="class_bembel_1_1_element_tree.html#af1837ca3dd10d0922264cd47618f5c66">More...</a><br /></td></tr>
<tr class="separator:af1837ca3dd10d0922264cd47618f5c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c2f97dbc1ab7db5e35951984595801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a48c2f97dbc1ab7db5e35951984595801">pbegin</a> () const</td></tr>
<tr class="memdesc:a48c2f97dbc1ab7db5e35951984595801"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterators  <a href="class_bembel_1_1_element_tree.html#a48c2f97dbc1ab7db5e35951984595801">More...</a><br /></td></tr>
<tr class="separator:a48c2f97dbc1ab7db5e35951984595801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b7b5b1e3f96db5f477f63d783b0e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a73b7b5b1e3f96db5f477f63d783b0e4d">pend</a> () const</td></tr>
<tr class="memdesc:a73b7b5b1e3f96db5f477f63d783b0e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator one past the end of the sequence represented by the leafs as ElementTreeNodes of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>.  <a href="class_bembel_1_1_element_tree.html#a73b7b5b1e3f96db5f477f63d783b0e4d">More...</a><br /></td></tr>
<tr class="separator:a73b7b5b1e3f96db5f477f63d783b0e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0096ebfa5f958d558ed6bff82927ceb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a0096ebfa5f958d558ed6bff82927ceb8">cpbegin</a> () const</td></tr>
<tr class="memdesc:a0096ebfa5f958d558ed6bff82927ceb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the sequence represented by the leafs as ElementTreeNodes of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>.  <a href="class_bembel_1_1_element_tree.html#a0096ebfa5f958d558ed6bff82927ceb8">More...</a><br /></td></tr>
<tr class="separator:a0096ebfa5f958d558ed6bff82927ceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c786a6da606f54e61ea599d1ae8856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a47c786a6da606f54e61ea599d1ae8856">cpend</a> () const</td></tr>
<tr class="memdesc:a47c786a6da606f54e61ea599d1ae8856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator one past the end of the sequence represented by the leafs as ElementTreeNodes of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>.  <a href="class_bembel_1_1_element_tree.html#a47c786a6da606f54e61ea599d1ae8856">More...</a><br /></td></tr>
<tr class="separator:a47c786a6da606f54e61ea599d1ae8856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f2b8130863eded89bb1e0055bbaaa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a50f2b8130863eded89bb1e0055bbaaa8">cluster_begin</a> (const <a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;cl) const</td></tr>
<tr class="memdesc:a50f2b8130863eded89bb1e0055bbaaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a cluster iterator to the beginning of the sequence represented by the the given <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>.  <a href="class_bembel_1_1_element_tree.html#a50f2b8130863eded89bb1e0055bbaaa8">More...</a><br /></td></tr>
<tr class="separator:a50f2b8130863eded89bb1e0055bbaaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade83cee307e4ac95eb69680422f59df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#ade83cee307e4ac95eb69680422f59df1">cluster_end</a> (const <a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;cl) const</td></tr>
<tr class="memdesc:ade83cee307e4ac95eb69680422f59df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a cluster iterator one past the end of the sequence represented by the the given <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>.  <a href="class_bembel_1_1_element_tree.html#ade83cee307e4ac95eb69680422f59df1">More...</a><br /></td></tr>
<tr class="separator:ade83cee307e4ac95eb69680422f59df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e1a6f0649a7d9f53497efebb6cf20f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a00e1a6f0649a7d9f53497efebb6cf20f">computeElementEnclosings</a> ()</td></tr>
<tr class="memdesc:a00e1a6f0649a7d9f53497efebb6cf20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes enclosing balls surrounding all elements.  <a href="class_bembel_1_1_element_tree.html#a00e1a6f0649a7d9f53497efebb6cf20f">More...</a><br /></td></tr>
<tr class="separator:a00e1a6f0649a7d9f53497efebb6cf20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e334f70cc2c81196232daabcd423f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#ab5e334f70cc2c81196232daabcd423f8">computeElementEnclosings_recursion</a> (<a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;el, const Eigen::MatrixXd &amp;P)</td></tr>
<tr class="memdesc:ab5e334f70cc2c81196232daabcd423f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes enclosing balls of one element and all its sons.  <a href="class_bembel_1_1_element_tree.html#ab5e334f70cc2c81196232daabcd423f8">More...</a><br /></td></tr>
<tr class="separator:ab5e334f70cc2c81196232daabcd423f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b6c430ecc4db446c328a0778a607b5"><td class="memItemLeft" align="right" valign="top"><a id="aa2b6c430ecc4db446c328a0778a607b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#aa2b6c430ecc4db446c328a0778a607b5">printPanels</a> () const</td></tr>
<tr class="memdesc:aa2b6c430ecc4db446c328a0778a607b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all Elements of the Tree. <br /></td></tr>
<tr class="separator:aa2b6c430ecc4db446c328a0778a607b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21c0ced557875579da6d2c3202c0f64"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#ac21c0ced557875579da6d2c3202c0f64">generateMidpointList</a> () const</td></tr>
<tr class="memdesc:ac21c0ced557875579da6d2c3202c0f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">other Stuff  <a href="class_bembel_1_1_element_tree.html#ac21c0ced557875579da6d2c3202c0f64">More...</a><br /></td></tr>
<tr class="separator:ac21c0ced557875579da6d2c3202c0f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747257a656cbc6790908bcf39f0abb7f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a747257a656cbc6790908bcf39f0abb7f">generateRadiusList</a> () const</td></tr>
<tr class="memdesc:a747257a656cbc6790908bcf39f0abb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix with all radii of the element enclosing.  <a href="class_bembel_1_1_element_tree.html#a747257a656cbc6790908bcf39f0abb7f">More...</a><br /></td></tr>
<tr class="separator:a747257a656cbc6790908bcf39f0abb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57f3f9ff67dc84b8549617ecf24593c"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#ad57f3f9ff67dc84b8549617ecf24593c">generateElementLabels</a> () const</td></tr>
<tr class="memdesc:ad57f3f9ff67dc84b8549617ecf24593c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with computed global indices of the elements.  <a href="class_bembel_1_1_element_tree.html#ad57f3f9ff67dc84b8549617ecf24593c">More...</a><br /></td></tr>
<tr class="separator:ad57f3f9ff67dc84b8549617ecf24593c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6e3bf7be28dbe0a4ccc7404984b2b2"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a6a6e3bf7be28dbe0a4ccc7404984b2b2">generatePatchBoundaryLabels</a> () const</td></tr>
<tr class="memdesc:a6a6e3bf7be28dbe0a4ccc7404984b2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate list of labels if elements are on the patch boundary or at the boundary of the geometry.  <a href="class_bembel_1_1_element_tree.html#a6a6e3bf7be28dbe0a4ccc7404984b2b2">More...</a><br /></td></tr>
<tr class="separator:a6a6e3bf7be28dbe0a4ccc7404984b2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a9c9dfa785e3a829a68c61b5a39ad6"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a77a9c9dfa785e3a829a68c61b5a39ad6">identifyPatch</a> (unsigned int pn) const</td></tr>
<tr class="memdesc:a77a9c9dfa785e3a829a68c61b5a39ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate list of labels if elements contained within a given patch.  <a href="class_bembel_1_1_element_tree.html#a77a9c9dfa785e3a829a68c61b5a39ad6">More...</a><br /></td></tr>
<tr class="separator:a77a9c9dfa785e3a829a68c61b5a39ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086f45e87786bfc2b20b128c7b8c1a3c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; int, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#a086f45e87786bfc2b20b128c7b8c1a3c">patchTopologyInfo</a> () const</td></tr>
<tr class="memdesc:a086f45e87786bfc2b20b128c7b8c1a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves neighborhood relations of the patches.  <a href="class_bembel_1_1_element_tree.html#a086f45e87786bfc2b20b128c7b8c1a3c">More...</a><br /></td></tr>
<tr class="separator:a086f45e87786bfc2b20b128c7b8c1a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b4a0f31ac5d2941768d0ef3a637b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bembel_1_1_element_tree.html#ad93b4a0f31ac5d2941768d0ef3a637b1">computeReorderingVector</a> () const</td></tr>
<tr class="memdesc:ad93b4a0f31ac5d2941768d0ef3a637b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ordering of elements in the element tree does not correspond to the element order underlying the coefficient vector. This reordering can be computed for look ups by this function.  <a href="class_bembel_1_1_element_tree.html#ad93b4a0f31ac5d2941768d0ef3a637b1">More...</a><br /></td></tr>
<tr class="separator:ad93b4a0f31ac5d2941768d0ef3a637b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011b2485f7253f3e31581faf45f1c28e"><td class="memItemLeft" align="right" valign="top"><a id="a011b2485f7253f3e31581faf45f1c28e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>compute_global_id</b> (const <a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;el) const</td></tr>
<tr class="separator:a011b2485f7253f3e31581faf45f1c28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a58f81b5d284dd488a9f3395ee1f6df51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f81b5d284dd488a9f3395ee1f6df51">&#9670;&nbsp;</a></span>ElementTree() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bembel::ElementTree::ElementTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class. </p>
<p>This copy constructor is explicitly deleted to prevent copying of <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> objects. </p>

</div>
</div>
<a id="ac61c6b51388520dc85221a9bef523345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61c6b51388520dc85221a9bef523345">&#9670;&nbsp;</a></span>ElementTree() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bembel::ElementTree::ElementTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move constructor for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class. </p>
<p>This move constructor is explicitly deleted to prevent moving of <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> objects. </p>

</div>
</div>
<a id="ae3b8984557610c903a2547b61c026406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b8984557610c903a2547b61c026406">&#9670;&nbsp;</a></span>ElementTree() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bembel::ElementTree::ElementTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructors </p>
<p>Default constructor for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class. </p>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00076">76</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a4516d4246aa5a37ce3fa6a02e3431114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4516d4246aa5a37ce3fa6a02e3431114">&#9670;&nbsp;</a></span>ElementTree() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bembel::ElementTree::ElementTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bembel_1_1_geometry.html">Geometry</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit constructor for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class. </p>
<p>This constructor initializes an <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> object for the provided geometry and maximum level. Currently this constructor is implemented for uniform refinement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The geometry object defining the patches. </td></tr>
    <tr><td class="paramname">max_level</td><td>(optional) The maximum level of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>. Default is 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00088">88</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a50f2b8130863eded89bb1e0055bbaaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f2b8130863eded89bb1e0055bbaaa8">&#9670;&nbsp;</a></span>cluster_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a> Bembel::ElementTree::cluster_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a cluster iterator to the beginning of the sequence represented by the the given <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cl</td><td>Const reference to the <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a> to start the iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html" title="iterator struct for element tree nodes. They may be used to iterator over the elements in a cluster....">ElementTreeNode::const_iterator</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00331">331</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="ade83cee307e4ac95eb69680422f59df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade83cee307e4ac95eb69680422f59df1">&#9670;&nbsp;</a></span>cluster_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a> Bembel::ElementTree::cluster_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a cluster iterator one past the end of the sequence represented by the the given <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cl</td><td>Const reference to the <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a> to start the iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html" title="iterator struct for element tree nodes. They may be used to iterator over the elements in a cluster....">ElementTreeNode::const_iterator</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00342">342</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a00e1a6f0649a7d9f53497efebb6cf20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e1a6f0649a7d9f53497efebb6cf20f">&#9670;&nbsp;</a></span>computeElementEnclosings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd Bembel::ElementTree::computeElementEnclosings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes enclosing balls surrounding all elements. </p>
<p>This functions sets the parameters midpoint_ radius_ of the <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a> objects stored in the tree.</p>
<dl class="section return"><dt>Returns</dt><dd>The point list as 3xN matrix with N the number of points. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00354">354</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="ab5e334f70cc2c81196232daabcd423f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e334f70cc2c81196232daabcd423f8">&#9670;&nbsp;</a></span>computeElementEnclosings_recursion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bembel::ElementTree::computeElementEnclosings_recursion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes enclosing balls of one element and all its sons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td><a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a> to start the recursion. </td></tr>
    <tr><td class="paramname">P</td><td>Point list of the vertices. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00368">368</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="ad93b4a0f31ac5d2941768d0ef3a637b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93b4a0f31ac5d2941768d0ef3a637b1">&#9670;&nbsp;</a></span>computeReorderingVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; Bembel::ElementTree::computeReorderingVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ordering of elements in the element tree does not correspond to the element order underlying the coefficient vector. This reordering can be computed for look ups by this function. </p>
<p>Limitation to the uniform case!</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the tensor product index of the elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00544">544</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a0096ebfa5f958d558ed6bff82927ceb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0096ebfa5f958d558ed6bff82927ceb8">&#9670;&nbsp;</a></span>cpbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a> Bembel::ElementTree::cpbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the sequence represented by the leafs as ElementTreeNodes of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html" title="iterator struct for element tree nodes. They may be used to iterator over the elements in a cluster....">ElementTreeNode::const_iterator</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00316">316</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a47c786a6da606f54e61ea599d1ae8856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c786a6da606f54e61ea599d1ae8856">&#9670;&nbsp;</a></span>cpend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a> Bembel::ElementTree::cpend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator one past the end of the sequence represented by the leafs as ElementTreeNodes of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html" title="iterator struct for element tree nodes. They may be used to iterator over the elements in a cluster....">ElementTreeNode::const_iterator</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00323">323</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="ad57f3f9ff67dc84b8549617ecf24593c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57f3f9ff67dc84b8549617ecf24593c">&#9670;&nbsp;</a></span>generateElementLabels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi Bembel::ElementTree::generateElementLabels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector with computed global indices of the elements. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector with global indices of the elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00447">447</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="adbd44db6cc7ad2caf32cdafb7f7e54ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd44db6cc7ad2caf32cdafb7f7e54ef">&#9670;&nbsp;</a></span>generateElementList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXi Bembel::ElementTree::generateElementList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return list of elements containing the indices of the vertices. </p>
<p>This function stores all indices of an element in the column of the returned matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>A 4xN integer Matrix where N is the number elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00240">240</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="ac21c0ced557875579da6d2c3202c0f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21c0ced557875579da6d2c3202c0f64">&#9670;&nbsp;</a></span>generateMidpointList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd Bembel::ElementTree::generateMidpointList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>other Stuff </p>
<p>Return a matrix with all midpoints of the elements.</p>
<dl class="section return"><dt>Returns</dt><dd>The midpoint list as 3xN matrix with N the number of points. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00417">417</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a6a6e3bf7be28dbe0a4ccc7404984b2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6e3bf7be28dbe0a4ccc7404984b2b2">&#9670;&nbsp;</a></span>generatePatchBoundaryLabels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi Bembel::ElementTree::generatePatchBoundaryLabels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate list of labels if elements are on the patch boundary or at the boundary of the geometry. </p>
<p>The value at the index of the element is 1 if the element is at the patch boundary and there is a neighbor patch. If there is no neighbor patch then the value is -1.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers of size N with N the number of elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00467">467</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="abebcceb563b798b9e06d4cc7f290af0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebcceb563b798b9e06d4cc7f290af0e">&#9670;&nbsp;</a></span>generatePointList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd Bembel::ElementTree::generatePointList </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXi *&#160;</td>
          <td class="paramname"><em>idct</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the coordinates of all points of the elements. </p>
<p>This function iterates all elements and returns the coordinates of the vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idct</td><td>Pointer to an Eigen::VectorXi to count how often a vertex is part of all elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3xN Matrix where N is the number of all vertices in the geometry. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00206">206</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a747257a656cbc6790908bcf39f0abb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747257a656cbc6790908bcf39f0abb7f">&#9670;&nbsp;</a></span>generateRadiusList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd Bembel::ElementTree::generateRadiusList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a matrix with all radii of the element enclosing. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the radii of the element enclosing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00432">432</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="af1837ca3dd10d0922264cd47618f5c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1837ca3dd10d0922264cd47618f5c66">&#9670;&nbsp;</a></span>get_geometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___geometry.html#ga2a0fac9275fef7f9601b40a644585cec">PatchVector</a>&amp; Bembel::ElementTree::get_geometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const reference to the <a class="el" href="class_bembel_1_1_geometry.html" title="this class wraps a GeometryVector and provides some basic functionality, like reading Geometry files">Geometry</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Const Reference to the PatchVector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00288">288</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="af2b2ff1bfaef5bce21b51f42b1a7e8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b2ff1bfaef5bce21b51f42b1a7e8ef">&#9670;&nbsp;</a></span>get_max_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bembel::ElementTree::get_max_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximum level of refinement. </p>
<dl class="section return"><dt>Returns</dt><dd>Level of refinement. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00270">270</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="abd179822f5abd8261b3cceed00d91061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd179822f5abd8261b3cceed00d91061">&#9670;&nbsp;</a></span>get_number_of_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bembel::ElementTree::get_number_of_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of elements in the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00264">264</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a5da89274800b8f17291dd801276f568d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da89274800b8f17291dd801276f568d">&#9670;&nbsp;</a></span>get_number_of_points()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bembel::ElementTree::get_number_of_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getter </p>
<p>Return number of points in the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of points. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00258">258</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a77a9c9dfa785e3a829a68c61b5a39ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a9c9dfa785e3a829a68c61b5a39ad6">&#9670;&nbsp;</a></span>identifyPatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi Bembel::ElementTree::identifyPatch </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate list of labels if elements contained within a given patch. </p>
<p>The value at the index of the element is 1 if the element is contained within the given patch. Otherwise its zero.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers of size N with N the number of elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00492">492</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="aa3769979afc7295c56ce721659d83b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3769979afc7295c56ce721659d83b93">&#9670;&nbsp;</a></span>init_ElementTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bembel::ElementTree::init_ElementTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bembel_1_1_geometry.html">Geometry</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>init </p>
<p>This function initializes the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a></p>
<p>First Each <a class="el" href="class_bembel_1_1_patch.html" title="handles a single patch">Patch</a> becomes an <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>. After resolving the patch neighborhood relations each patch gets refined to the common maximum level of refinement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The geometry object defining the patches. </td></tr>
    <tr><td class="paramname">max_level</td><td>(optional) The maximum level of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>. Default is 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00105">105</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="afc2b31137879d87979e701ed6803938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2b31137879d87979e701ed6803938e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a>&amp; Bembel::ElementTree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class. </p>
<p>This copy assignment operator is explicitly deleted to prevent copying of <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> objects.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the updated <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> object. </dd></dl>

</div>
</div>
<a id="a117f48957a95fe215903265c731aef6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117f48957a95fe215903265c731aef6d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a>&amp; Bembel::ElementTree::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move assignment operator for the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> class. </p>
<p>This move assignment operator is explicitly deleted to prevent moving of <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> objects.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the updated <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a> object. </dd></dl>

</div>
</div>
<a id="a086f45e87786bfc2b20b128c7b8c1a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086f45e87786bfc2b20b128c7b8c1a3c">&#9670;&nbsp;</a></span>patchTopologyInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::array&lt;int, 4&gt; &gt; Bembel::ElementTree::patchTopologyInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolves neighborhood relations of the patches. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector where each entry defines a patch interface or boundary. The entries correspond to [patchIndex1, edgeCase1, patchIndex2, edgeCase2]. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00510">510</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a48c2f97dbc1ab7db5e35951984595801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c2f97dbc1ab7db5e35951984595801">&#9670;&nbsp;</a></span>pbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a> Bembel::ElementTree::pbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iterators </p>
<p>Returns an iterator to the beginning of the sequence represented by the leafs as ElementTreeNodes of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html" title="iterator struct for element tree nodes. They may be used to iterator over the elements in a cluster....">ElementTreeNode::const_iterator</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00298">298</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a73b7b5b1e3f96db5f477f63d783b0e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b7b5b1e3f96db5f477f63d783b0e4d">&#9670;&nbsp;</a></span>pend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html">ElementTreeNode::const_iterator</a> Bembel::ElementTree::pend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator one past the end of the sequence represented by the leafs as ElementTreeNodes of the <a class="el" href="class_bembel_1_1_element_tree.html" title="This class organizes an element structure on a Geometry object and handles refinement.">ElementTree</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="struct_bembel_1_1_element_tree_node_1_1const__iterator.html" title="iterator struct for element tree nodes. They may be used to iterator over the elements in a cluster....">ElementTreeNode::const_iterator</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00307">307</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="ae531dd7026ef12de425795fed380d7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae531dd7026ef12de425795fed380d7dc">&#9670;&nbsp;</a></span>refineUniformly_recursion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bembel::ElementTree::refineUniformly_recursion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a> &amp;&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine the given element or it's sons. </p>
<p>This function refines an element recursively. If the given element is already refined than iterate all sons and refine them and so on. </p>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00169">169</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="af3bb605f06602d6c962e2e6b04668f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bb605f06602d6c962e2e6b04668f07">&#9670;&nbsp;</a></span>root() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a>&amp; Bembel::ElementTree::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to the root <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the root <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00276">276</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<a id="a26d696de6baf21b29b55411f04dd98ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d696de6baf21b29b55411f04dd98ce">&#9670;&nbsp;</a></span>root() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_bembel_1_1_element_tree_node.html">ElementTreeNode</a>&amp; Bembel::ElementTree::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const reference to the root <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Const Reference to the root <a class="el" href="class_bembel_1_1_element_tree_node.html" title="The ElementTreeNode corresponds to an element in the element tree.">ElementTreeNode</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_element_tree_8hpp_source.html#l00282">282</a> of file <a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Bembel/src/ClusterTree/<a class="el" href="_element_tree_8hpp_source.html">ElementTree.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_bembel.html">Bembel</a></li><li class="navelem"><a class="el" href="class_bembel_1_1_element_tree.html">ElementTree</a></li>
    <li class="footer">Generated on Mon Sep 30 2024 07:06:53 for Bembel by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
